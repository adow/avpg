# 3. AVFoundation Programming Guide - Playback

原文地址： [https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02\_Playback.html#//apple\_ref/doc/uid/TP40010188-CH3-SW1](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW1)

大纲:

- 播放 Assets Playing Assets
- 处理不同类似的 Asset Handling Different Types of Asset
- 播放 Playing an Item
	- 改变速度 Changing the Playback Rate
	- 定位-重设播放头位置 Seeking—Repositioning the Playhead
- 播放多个项目 Playing Multiple Items
- 监视播放 Monitoring Playback
	- 响应状态的变化 Responding to a Change in Status
	- 追踪视频的可播放状态 Tracking Readiness for Visual Display
	- 追踪时间 Tracking Time
	- 播放结束 Reaching the End of an Item
- 整合在一起：使用 `AVPlayerLayer` 来播放一个视频文件 Putting It All Together: Playing a Video File Using AVPlayerLayer
	- 播放视图 The Player View
	- 简单的视图控制器 A Simple View Controller
	- 创建 Asset  Creating the Asset
	- 响应播放条目状态修改 Responding to the Player Item’s Status Change
	- 播放  Playing the Item

## 播放 Playback

To control the playback of assets, you use an AVPlayer object. During playback, you can use an [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem) instance to manage the presentation state of an asset as a whole, and an [AVPlayerItemTrack](https://developer.apple.com/documentation/avfoundation/avplayeritemtrack) object to manage the presentation state of an individual track. To display video, you use an [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) object.

使用 `AVPlayer` 来播放一个 `asset`。在播放的过程中，可以使用 [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem) 来管理整个对象，使用 [AVPlayerItemTrack](https://developer.apple.com/documentation/avfoundation/avplayeritemtrack) 来管理单个轨道的播放状态。使用 [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) 来显示视频。

### 播放 Assets Playing Assets

A player is a controller object that you use to manage playback of an asset, for example starting and stopping playback, and seeking to a particular time. You use an instance of [AVPlayer](https://developer.apple.com/documentation/avfoundation/avplayer) to play a single asset. You can use an [AVQueuePlayer](https://developer.apple.com/documentation/avfoundation/avqueueplayer) object to play a number of items in sequence (AVQueuePlayer is a subclass of AVPlayer). On OS X you have the option of the using the AVKit framework’s AVPlayerView class to play the content back within a view.

你可以用 `player` 要来管理 asset 的播放状态，比如开始，结束播放，跳转到指定时间。你可以用 [AVPlayer](https://developer.apple.com/documentation/avfoundation/avplayer) 对象来播放一个 `asset`。还可以使用 [AVQueuePlayer](https://developer.apple.com/documentation/avfoundation/avqueueplayer) （他是 `AVPlayer` 子类）来播放列表。在 `OS X` 上面，你还可以使用 `AVKit` 框架中的 `AVPlayerView` 对象来播放。

A player provides you with information about the state of the playback so, if you need to, you can synchronize your user interface with the player’s state. You typically direct the output of a player to a specialized Core Animation layer (an instance of [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) or [AVSynchronizedLayer](https://developer.apple.com/documentation/avfoundation/avsynchronizedlayer)). To learn more about layers, see [Core Animation Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514).

播放器 (`player`) 中提供了播放中时的所有信息，所以你可以用来和播放器界面同步状态。最常见的情况是，你可以把 `player` 内容直接输出到一个 `Core Animation` 图层（[AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) 或者 [AVSynchronizedLayer](https://developer.apple.com/documentation/avfoundation/avsynchronizedlayer) 的实例）。关于图层，可以参考 [Core Animation Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514)

Multiple player layers: You can create many AVPlayerLayer objects from a single AVPlayer instance, but only the most recently created such layer will display any video content onscreen.

关于多个播放图层：虽然你可以用一个 `AVPlayer` 对象来创建多个 `AVPlayerLayer` 对象，但是只有最新创建的一个图层可以播放视频。

Although ultimately you want to play an asset, you don’t provide assets directly to an AVPlayer object. Instead, you provide an instance of [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem). A player item manages the presentation state of an asset with which it is associated. A player item contains player item tracks—instances of [AVPlayerItemTrack](https://developer.apple.com/documentation/avfoundation/avplayeritemtrack)—that correspond to the tracks in the asset. The relationship between the various objects is shown in Figure 2-1.


你并不能使用 `AVPlayer` 来直接播放 `asset`。你需要创建一个 [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem) 对象，他可以管理 `asset` 的播放状态。`AVPlayerItem` 包含了很多轨道信息（[AVPlayerItemTrack](https://developer.apple.com/documentation/avfoundation/avplayeritemtrack) 对象）。关于这些对象之间的关系

![](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Art/avplayerLayer_2x.png)

This abstraction means that you can play a given asset using different players simultaneously, but rendered in different ways by each player. Figure 2-2 shows one possibility, with two different players playing the same asset, with different settings. Using the item tracks, you can, for example, disable a particular track during playback (for example, you might not want to play the sound component).

这种抽象方式意味着你可用不同的播放器同时以不同的方式来播放同一个 `asset`。2-2 示例了，用两个不同的播放播放同一个 `asset`，但是使用了不同的设置。通过 `item tracks`,你可以在播放的时候选择特定的轨道（比如你可能不想播放声音）。

![](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Art/playerObjects_2x.png)

You can initialize a player item with an existing asset, or you can initialize a player item directly from a URL so that you can play a resource at a particular location (AVPlayerItem will then create and configure an asset for the resource). As with AVAsset, though, simply initializing a player item doesn’t necessarily mean it’s ready for immediate playback. You can observe (using key-value observing) an item’s [status](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389493-status) property to determine if and when it’s ready to play.

你可以用一个现成的 `asset` 来创建一个播放条目 (`Player item`)，也可以直接用一个 URL 来创建一个 `Player Item`,所以你可以用来播放一个基于地址的资源（AVPlayer 会自动为这个资源创建和配置一个 asset). 注意你使用 `AVAsset` 创建一个 `Player Item` 并不意味着他已经可以立刻就被播放了。通过观察 `Player Item` 的 [status](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389493-status) 属性来确定是否可以播放了。（使用 Key-value observing)

### 处理不同类似的 Asset Handling Different Types of Asset

The way you configure an asset for playback may depend on the sort of asset you want to play. Broadly speaking, there are two main types: file-based assets, to which you have random access (such as from a local file, the camera roll, or the Media Library), and stream-based assets (HTTP Live Streaming format).

如何配置播放取决于 asset 的类型。广义上说，有两种主要的类型：基于文件的 asset（比如本地文件，相机照片或者媒体库文件），可以进行随机访问。还有基于流的 asset （HTTP Live Streaming format)

To load and play a file-based asset. There are several steps to playing a file-based asset:

- Create an asset using [AVURLAsset](https://developer.apple.com/documentation/avfoundation/avurlasset).
- Create an instance of AVPlayerItem using the asset.
- Associate the item with an instance of AVPlayer.
- Wait until the item’s status property indicates that it’s ready to play (typically you use key-value observing to receive a notification when the status changes).

要载入和播放一个基于文件的 asset，需要做下面几步：

- 创建一个 [AVURLAsset](https://developer.apple.com/documentation/avfoundation/avurlasset);
- 用这个 asset 来创建一个 `AVPlayerItem` 对象；
- 把这个实例和播放器关联起来 `AVPlayer`;
- 观察这个 `Player Item`，等待变成可以播放的状态；（一般使用 `key-value observing` 观察 `status` 来获取状态变化通知）

This approach is illustrated in [Putting It All Together: Playing a Video File Using AVPlayerLayer](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW2).

具体的代码示例，参考 [Putting It All Together: Playing a Video File Using AVPlayerLayer](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW2)

To create and prepare an HTTP live stream for playback. Initialize an instance of AVPlayerItem using the URL. (You cannot directly create an AVAsset instance to represent the media in an HTTP Live Stream.)

要播放 HTTP 直播流，可以用 URL 来创建一个 `AVPlayerItem`。（你不能直接创建基于 HTTP 直播流的 AVAsset 对象）。

	NSURL *url = [NSURL URLWithString:@"<#Live stream URL#>];
	// You may find a test stream at <http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8>.
	self.playerItem = [AVPlayerItem playerItemWithURL:url];
	[playerItem addObserver:self forKeyPath:@"status" options:0 context:&ItemStatusContext];
	self.player = [AVPlayer playerWithPlayerItem:playerItem];


When you associate the player item with a player, it starts to become ready to play. When it is ready to play, the player item creates the AVAsset and AVAssetTrack instances, which you can use to inspect the contents of the live stream.

To get the duration of a streaming item, you can observe the [duration](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389386-duration) property on the player item. When the item becomes ready to play, this property updates to the correct value for the stream.

将 `Player Item` 和播放器进行关联，他将开始进入准备状态。当进入可播放状态的时候，`Player Item` 会创建 `AVAsset` 和 `AVAssetTrack`  对象，你可以在其中获取到直播流的具体内容。

你可以通过观察播放器条目（`Player Item`） 的 [duration](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389386-duration) 属性来获取时长。只有进入准备播放的状态的时候，我们才能获取到正确的值。

Note: Using the duration property on the player item requires iOS 4.3 or later. An approach that is compatible with all versions of iOS involves observing the [duration](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389386-duration) property of the player item. When the [status](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389493-status) becomes [AVPlayerItemStatusReadyToPlay](https://developer.apple.com/documentation/avfoundation/avplayeritemstatus/avplayeritemstatusreadytoplay), the duration can be fetched with the following line of code:

提示：要 `iOS 4.3 ` 和以后的版本才可以获取到正确的时长。在 iOS 中通过观察 [duration](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389386-duration) 属性是对所有的 iOS 版本都兼容的。当 [status](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389493-status) 变成 [AVPlayerItemStatusReadyToPlay](https://developer.apple.com/documentation/avfoundation/avplayeritemstatus/avplayeritemstatusreadytoplay) 的时候，可以通过下面代码来获取时长

	[[[[[playerItem tracks] objectAtIndex:0] assetTrack] asset] duration];

If you simply want to play a live stream, you can take a shortcut and create a player directly using the URL use the following code:

也可以通过 URL 来快速的播放一个直播流，使用下面的代码

	self.player = [AVPlayer playerWithURL:<#Live stream URL#>];
	[player addObserver:self forKeyPath:@"status" options:0 context:&PlayerStatusContext];

As with assets and items, initializing the player does not mean it’s ready for playback. You should observe the player’s [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) property, which changes to [AVPlayerStatusReadyToPlay](https://developer.apple.com/documentation/avfoundation/avplayerstatus/avplayerstatusreadytoplay) when it is ready to play. You can also observe the [currentItem](https://developer.apple.com/documentation/avfoundation/avplayer/1387569-currentitem) property to access the player item created for the stream.

和 `AVAsset` 以及 `Player Item` 一样，初始化好播放器并不意味着就可以开始播放了，你还是需要观察播放器的 [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) 属性，当变成 [AVPlayerStatusReadyToPlay](https://developer.apple.com/documentation/avfoundation/avplayerstatus/avplayerstatusreadytoplay) 的时候才可以播放。你也可以通过观察 [currentItem](https://developer.apple.com/documentation/avfoundation/avplayer/1387569-currentitem) 属性来访问播放器中流的播放条目。

If you don’t know what kind of URL you have, follow these steps:

1. Try to initialize an AVURLAsset using the URL, then load its tracks key.If the tracks load successfully, then you create a player item for the asset.  

2. If 1 fails, create an AVPlayerItem directly from the URL.Observe the player’s [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) property to determine whether it becomes playable.  

If either route succeeds, you end up with a player item that you can then associate with a player.

如果你不能确定 URL 的类型，需要做下面的：

1. 用 URL 来创建 `AVURLAsset` 对象，然后加载 `tracks` 键。载入成功后，你可以用他来创建一个 `Player Item` 对象。
2. 如果第一步失败了，你可以用 URL来直接创建一个 `AVPlayerItem` 对象。然后观察 [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) 属性，等待他可以播放的时候来确定他。

当以上有一个操作成功后，你就将一个 `Player Item` 和播放器关联在了一起。

### 播放 Playing an Item

To start playback, you send a [play](https://developer.apple.com/documentation/avfoundation/avplayer/1386726-play) message to the player.

要开始播放，只要调用 `player` 的 `play` 方法。

	- (IBAction)play:sender {
	    [player play];
	}

In addition to simply playing, you can manage various aspects of the playback, such as the rate and the location of the playhead. You can also monitor the play state of the player; this is useful if you want to, for example, synchronize the user interface to the presentation state of the asset—see [Monitoring Playback](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW8).

除了简单的播放之外，你还可以管理包括速度和播放头位置在内的其他内容。你还可以观察播放器的状态，比如你可以用来将 asset 的呈现状态 (presentation state) 和界面进行同步。参考 [Monitoring Playback](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW8)

#### 改变速度 Changing the Playback Rate

You change the rate of playback by setting the player’s [rate](https://developer.apple.com/documentation/avfoundation/avplayer/1388846-rate) property.

你可以通过修改播放器的 [rate](https://developer.apple.com/documentation/avfoundation/avplayer/1388846-rate) 属性来变速。

	aPlayer.rate = 0.5;
	aPlayer.rate = 2.0;

A value of 1.0 means “play at the natural rate of the current item”. Setting the rate to 0.0 is the same as pausing playback—you can also use [pause](https://developer.apple.com/documentation/avfoundation/avplayer/1387895-pause).

1.0 意味着是原速,设置为 `0.0` 会暂停播放，你也可以调用 [pause](https://developer.apple.com/documentation/avfoundation/avplayer/1387895-pause) 方法。

Items that support reverse playback can use the rate property with a negative number to set the reverse playback rate. You determine the type of reverse play that is supported by using the playerItem properties [canPlayReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1385591-canplayreverse) (supports a rate value of -1.0), [canPlaySlowReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390598-canplayslowreverse) (supports rates between 0.0 and -1.0) and [canPlayFastReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390493-canplayfastreverse) (supports rate values less than -1.0).

有些播放条目还可以进行倒过来播放，通过设置一个负值的 `rate`。你可以通过 `playItem` 的 [canPlayReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1385591-canplayreverse) （可以设置 -1.0) 来确定是否可以倒放，[canPlaySlowReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390598-canplayslowreverse) (设置范围 0.0 到 -1.0), 以及 [canPlayFastReverse](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390493-canplayfastreverse) (可以设置少于 -1.0).

#### 定位-重设播放头位置 Seeking—Repositioning the Playhead

To move the playhead to a particular time, you generally use seekToTime: as follows:

要想把播放头定位到一个特定的时间，你只需要使用 [seekToTime:](https://developer.apple.com/documentation/avfoundation/avplayer/1385953-seektotime)

	CMTime fiveSecondsIn = CMTimeMake(5, 1);
	[player seekToTime:fiveSecondsIn];

The `seekToTime:` method, however, is tuned for performance rather than precision. If you need to move the playhead precisely, instead you use [seekToTime:toleranceBefore:toleranceAfter:](https://developer.apple.com/documentation/avfoundation/avplayer/1387741-seektotime) as in the following code fragment:

但是需要注意的是，`seekToTime` 着重与性能而不是精度。所以如果你需要精确的移动播放头位置，你可以使用 [seekToTime:toleranceBefore:toleranceAfter:](https://developer.apple.com/documentation/avfoundation/avplayer/1387741-seektotime)

	CMTime fiveSecondsIn = CMTimeMake(5, 1);
	[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];

Using a tolerance of zero may require the framework to decode a large amount of data. You should use zero only if you are, for example, writing a sophisticated media editing application that requires precise control.

使用这种高精度的定位需要框架解码大量的数据，所以你只有必要的情况下才进行这种操作，比如你正在写一个需要精确控制的媒体编辑程序的时候。

After playback, the player’s head is set to the end of the item and further invocations of play have no effect. To position the playhead back at the beginning of the item, you can register to receive an [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification) notification from the item. In the notification’s callback method, you invoke seekToTime: with the argument `kCMTimeZero`.

在播放完成后，播放头就被定位到播放条目的结尾处，再次调用播放也不会有任何作用。所以你可以通过接收 [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification) 获得播放结束的通知，然后通过 `seekToTime:` 和 `kCMTimeZero`参数来定位到开头。

	// Register with the notification center after creating the player item.
	    [[NSNotificationCenter defaultCenter]
	        addObserver:self
	        selector:@selector(playerItemDidReachEnd:)
	        name:AVPlayerItemDidPlayToEndTimeNotification
	        object:<#The player item#>];
	 
	- (void)playerItemDidReachEnd:(NSNotification *)notification {
	    [player seekToTime:kCMTimeZero];
	}
	

### 播放多个项目 Playing Multiple Items

You can use an [AVQueuePlayer](https://developer.apple.com/documentation/avfoundation/avqueueplayer) object to play a number of items in sequence. The AVQueuePlayer class is a subclass of AVPlayer. You initialize a queue player with an array of player items.

你可以使用 [AVQueuePlayer](https://developer.apple.com/documentation/avfoundation/avqueueplayer) 对象来播放一组队列。他是 `AVPlayer` 的子类，通过一个播放条目的数组（player items) 来创建对象。

	NSArray *items = <#An array of player items#>;
	AVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];
	

You can then [play](https://developer.apple.com/documentation/avfoundation/avplayer/1386726-play) the queue using play, just as you would an AVPlayer object. The queue player plays each item in turn. If you want to skip to the next item, you send the queue player an [advanceToNextItem](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1389318-advancetonextitem) message.

You can modify the queue using [insertItem:afterItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1388543-insertitem), [removeItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1387400-remove), and [removeAllItems](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1385788-removeallitems). When adding a new item, you should typically check whether it can be inserted into the queue, using [canInsertItem:afterItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1387289-caninsert). You pass nil as the second argument to test whether the new item can be appended to the queue.

你可以像使用 `AVPlayer` 对象一样调用 [play](https://developer.apple.com/documentation/avfoundation/avplayer/1386726-play)方法来播放队列。播放器会依照队列依次播放。还可以通过 [advanceToNextItem](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1389318-advancetonextitem) 来跳过到下一个。

你可以用[insertItem:afterItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1388543-insertitem), [removeItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1387400-remove) 和 [removeAllItems](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1385788-removeallitems) 来修改队列。在添加播放条目的时候，你一般要先检查一下是否可以这么做，使用 [canInsertItem:afterItem:](https://developer.apple.com/documentation/avfoundation/avqueueplayer/1387289-caninsert)。你也可以为第二个参数传递 `nil`, 这样他就是检查能否在队列的结尾处添加播放条目。

	AVPlayerItem *anItem = <#Get a player item#>;
	if ([queuePlayer canInsertItem:anItem afterItem:nil]) {
	    [queuePlayer insertItem:anItem afterItem:nil];
	}
	

### 监视播放 Monitoring Playback

You can monitor a number of aspects of both the presentation state of a player and the player item being played. This is particularly useful for state changes that are not under your direct control. For example:

- If the user uses multitasking to switch to a different application, a player’s [rate](https://developer.apple.com/documentation/avfoundation/avplayer/1388846-rate) property will drop to 0.0.
- If you are playing remote media, a player item’s [loadedTimeRanges](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389953-loadedtimeranges) and [seekableTimeRanges](https://developer.apple.com/documentation/avfoundation/avplayeritem/1386155-seekabletimeranges) properties will change as more data becomes available.These properties tell you what portions of the player item’s timeline are available.
- A player’s [currentItem](https://developer.apple.com/documentation/avfoundation/avplayer/1387569-currentitem) property changes as a player item is created for an HTTP live stream.
- A player item’s [tracks](https://developer.apple.com/documentation/avfoundation/avplayeritem/1386361-tracks) property may change while playing an HTTP live stream.This may happen if the stream offers different encodings for the content; the tracks change if the player switches to a different encoding.
- A player or player item’s [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) property may change if playback fails for some reason.

You can use key-value observing to monitor changes to values of these properties.

在播放的时候你可以监视播放器和播放条目的显示状态。这在你无法直接控制播放状态的时候就非常有用。比如

- 如果正在进行多应用程序切换，播放器的速度 [rate](https://developer.apple.com/documentation/avfoundation/avplayer/1388846-rate) 会变成 0.0.
- 如果你正在播放远程媒体资源，播放条目的 [loadedTimeRanges](https://developer.apple.com/documentation/avfoundation/avplayeritem/1389953-loadedtimeranges) 属性和 [seekableTimeRanges](https://developer.apple.com/documentation/avfoundation/avplayeritem/1386155-seekabletimeranges) 属性就会随着数据加载而改变。这些属性用来告诉你播放条目的时间线中哪部分是可用的。
- 对于 HTTP 直播流，播放器的 [currentItem](https://developer.apple.com/documentation/avfoundation/avplayer/1387569-currentitem "currentItem") 属性会改变；
- 当播放 HTTP 直播流的时候，播放条目的 [tracks](https://developer.apple.com/documentation/avfoundation/avplayeritem/1386361-tracks) 属性也可能改变。当流提供不同的编码器时，比如播放器在不同的编码器切换的时候，[tracks](https://developer.apple.com/documentation/avfoundation/avplayeritem/1386361-tracks) 属性就会变化；
- 播放器或者播放条目的 [status](https://developer.apple.com/documentation/avfoundation/avplayer/1388096-status) 属性在一些播放错误的时候也会改变。

你可以通过使用 `key-value observing` 来监视这些属性变化。

Important: You should register for KVO change notifications and unregister from KVO change notifications on the main thread. This avoids the possibility of receiving a partial notification if a change is being made on another thread. AV Foundation invokes [observeValueForKeyPath:ofObject:change:context:](https://developer.apple.com/documentation/objectivec/nsobject/1416553-observevalueforkeypath) on the main thread, even if the change operation is made on another thread.

需要注意的事项：你应该在主线程中注册和取消注册 `KVO` 通知。否则当其他的线程发出通知时，就可能有一些丢失的情况。不管这些属性修改操作是发生在哪个线程，`AVFoundation` 总是在主线程调用 [observeValueForKeyPath:ofObject:change:context:](https://developer.apple.com/documentation/objectivec/nsobject/1416553-observevalueforkeypath)。

#### 响应状态的变化 Responding to a Change in Status

When a player or player item’s status changes, it emits a key-value observing change notification. If an object is unable to play for some reason (for example, if the media services are reset), the status changes to [AVPlayerStatusFailed](https://developer.apple.com/documentation/avfoundation/avplayerstatus/1385773-failed) or [AVPlayerItemStatusFailed](https://developer.apple.com/documentation/avfoundation/avplayeritemstatus/avplayeritemstatusfailed) as appropriate. In this situation, the value of the object’s error property is changed to an error object that describes why the object is no longer be able to play.

AV Foundation does not specify what thread that the notification is sent on. If you want to update the user interface, you must make sure that any relevant code is invoked on the main thread. This example uses `dispatch_async` to execute code on the main thread.

当一个播放器或者播放器状态改变的时候，他会发出 `key-value` 变化通知。当他由于一些原因不能正常播放的时候（比如可能一些媒体服务器被重置了），就会变成 [AVPlayerStatusFailed](https://developer.apple.com/documentation/avfoundation/avplayerstatus/1385773-failed) 或者 [AVPlayerItemStatusFailed](https://developer.apple.com/documentation/avfoundation/avplayeritemstatus/avplayeritemstatusfailed) 状态。在这种情况下，他的 `error` 属性会被修改并指明了为什么无法继续播放。

`AVFoundation` 不会指定通知从哪个线程发出。所以如果你必须要在主线程中来以此更新界面。下面的例子使用 `dispatch_async` 在主线程中执行代码：

	- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
	                        change:(NSDictionary *)change context:(void *)context {
	 
	    if (context == <#Player status context#>) {
	        AVPlayer *thePlayer = (AVPlayer *)object;
	        if ([thePlayer status] == AVPlayerStatusFailed) {
	            NSError *error = [<#The AVPlayer object#> error];
	            // Respond to error: for example, display an alert sheet.
	            return;
	        }
	        // Deal with other status change if appropriate.
	    }
	    // Deal with other change notifications if appropriate.
	    [super observeValueForKeyPath:keyPath ofObject:object
	           change:change context:context];
	    return;
	}
	


#### 追踪视频的可播放状态 Tracking Readiness for Visual Display

You can observe an [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) object’s [readyForDisplay](https://developer.apple.com/documentation/avfoundation/avplayerlayer/1389748-isreadyfordisplay) property to be notified when the layer has user-visible content. In particular, you might insert the player layer into the layer tree only when there is something for the user to look at and then perform a transition from.

你可以通过观察播放器图层 ([AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer)） 的 [readyForDisplay](https://developer.apple.com/documentation/avfoundation/avplayerlayer/1389748-isreadyfordisplay) 属性来确定是否有内容显示给用户。在实际做的时候，你可能只有在需要将内容展示给用户的时候才将图层插入到视图中。

#### 追踪时间 Tracking Time

To track changes in the position of the playhead in an AVPlayer object, you can use [addPeriodicTimeObserverForInterval:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1385829-addperiodictimeobserver) or [addBoundaryTimeObserverForTimes:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1388027-addboundarytimeobserver). You might do this to, for example, update your user interface with information about time elapsed or time remaining, or perform some other user interface synchronization.

- With [addPeriodicTimeObserverForInterval:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1385829-addperiodictimeobserver), the block you provide is invoked at the interval you specify, if time jumps, and when playback starts or stops.
- With [addBoundaryTimeObserverForTimes:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1388027-addboundarytimeobserver), you pass an array of CMTime structures contained in NSValue objects. The block you provide is invoked whenever any of those times is traversed.

你可以通过 [addPeriodicTimeObserverForInterval:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1385829-addperiodictimeobserver) 和  [addBoundaryTimeObserverForTimes:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1388027-addboundarytimeobserver) 来追踪播放器中播放头位置的变化。通过这样的方式，你可以用来同步更新界面中的播放时间和剩余时间。

- 通过 [addPeriodicTimeObserverForInterval:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1385829-addperiodictimeobserver)，你将会在指定的时间或者时间跳转，或者播放器开始结束的时候得到回调。
- 使用 [addBoundaryTimeObserverForTimes:queue:usingBlock:](https://developer.apple.com/documentation/avfoundation/avplayer/1388027-addboundarytimeobserver)，需要指定一个 NSValue 的数组（其中包裹这 CMTime)。每到一个时间的时候，你就会得到回调。

Both of the methods return an opaque object that serves as an observer. You must keep a strong reference to the returned object as long as you want the time observation block to be invoked by the player. You must also balance each invocation of these methods with a corresponding call to [removeTimeObserver:](https://developer.apple.com/documentation/avfoundation/avplayer/1387552-removetimeobserver).

以上两个方法都会返回一个不透明的 `observer` 对象，你必须在使用的过程中对他们保持强引用。你可以通过调用与之配套的 [removeTimeObserver:](https://developer.apple.com/documentation/avfoundation/avplayer/1387552-removetimeobserver) 来取消这个观察对象。

With both of these methods, AV Foundation does not guarantee to invoke your block for every interval or boundary passed. AV Foundation does not invoke a block if execution of a previously invoked block has not completed. You must make sure, therefore, that the work you perform in the block does not overly tax the system.

`AVFoundation` 并不能保证每次都是在指定的时间点来触发这两个方法。当前面一次没有回调没有执行完成的时候，他就不会被调用。所以一定要确定，你的回调函数中并不会为系统带来过多的负担。

	// Assume a property: @property (strong) id playerObserver;
	 
	Float64 durationSeconds = CMTimeGetSeconds([<#An asset#> duration]);
	CMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);
	CMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);
	NSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue valueWithCMTime:secondThird]];
	 
	self.playerObserver = [<#A player#> addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{
	 
	    NSString *timeDescription = (NSString *)
	        CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime]));
	    NSLog(@"Passed a boundary at %@", timeDescription);
	}];
	


#### 播放结束 Reaching the End of an Item

You can register to receive an [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification) notification when a player item has completed playback.

你可以通过 [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification) 来在在播放结束的时候获得通知。

	[[NSNotificationCenter defaultCenter] addObserver:<#The observer, typically self#>
	                                         selector:@selector(<#The selector name#>)
	                                             name:AVPlayerItemDidPlayToEndTimeNotification
	                                           object:<#A player item#>];
	

### 整合在一起：使用 `AVPlayerLayer` 来播放一个视频文件 Putting It All Together: Playing a Video File Using AVPlayerLayer

This brief code example illustrates how you can use an [AVPlayer](https://developer.apple.com/documentation/avfoundation/avplayer) object to play a video file. It shows how to:

- Configure a view to use an AVPlayerLayer layer
- Create an AVPlayer object
- Create an AVPlayerItem object for a file-based asset and use key-value observing to observe its status
- Respond to the item becoming ready to play by enabling a button
- Play the item and then restore the player’s head to the beginning

下面这个简单的代码示例展示了如何使用 [AVPlayer](https://developer.apple.com/documentation/avfoundation/avplayer)  来播放一个视频文件：

- 用 `AVPlayerLayer` 图层来配置一个视图;
- 创建 `AVPlayer` 对象;
- 使用一个基于文件的 `Asset` 来创建一个播放条目 `AVPlayerItem`，并使用 `key-value observing` 来观察他的状态 `status` 属性变化;
- 在可以播放的时候才将播放按钮设置为可用；
- 播放之后将播放头重新恢复到开始的位置；

Note: To focus on the most relevant code, this example omits several aspects of a complete application, such as memory management and unregistering as an observer (for key-value observing or for the notification center). To use AV Foundation, you are expected to have enough experience with Cocoa to be able to infer the missing pieces

提示：为了在示例中着重介绍相关代码的使用，这里省略了很多完整程序中需要的部分，比如内存管理和取消注册观察者；在使用 `AVFoundation` 前，你需要对于 Cocoa 开发有足够多的经验以此来补全这些被忽略的代码；

For a conceptual introduction to playback, skip to [Playing Assets](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW4).

关于播放的介绍，可以查看 [Playing Assets](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/02_Playback.html#//apple_ref/doc/uid/TP40010188-CH3-SW4)。

#### 播放视图 The Player View

To play the visual component of an asset, you need a view containing an [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) layer to which the output of an AVPlayer object can be directed. You can create a simple subclass of [UIView](https://developer.apple.com/documentation/uikit/uiview) to accommodate this:

要播放一个视频的 `asset`, 你需要一个包含了 [AVPlayerLayer](https://developer.apple.com/documentation/avfoundation/avplayerlayer) 图层的视图，他被用来接收 `AVPlayer` 对象输出的内容。你可以通过简单的继承一个 [UIView](https://developer.apple.com/documentation/uikit/uiview) 来包裹一个图层：

	#import <UIKit/UIKit.h>
	#import <AVFoundation/AVFoundation.h>
	 
	@interface PlayerView : UIView
	@property (nonatomic) AVPlayer *player;
	@end
	 
	@implementation PlayerView
	+ (Class)layerClass {
	    return [AVPlayerLayer class];
	}
	- (AVPlayer*)player {
	    return [(AVPlayerLayer *)[self layer] player];
	}
	- (void)setPlayer:(AVPlayer *)player {
	    [(AVPlayerLayer *)[self layer] setPlayer:player];
	}
	@end
	

#### 简单的视图控制器 A Simple View Controller

Assume you have a simple view controller, declared as follows:

假定你有一个简单的视图控制器，使用如下的声明：

	@class PlayerView;
	@interface PlayerViewController : UIViewController
	 
	@property (nonatomic) AVPlayer *player;
	@property (nonatomic) AVPlayerItem *playerItem;
	@property (nonatomic, weak) IBOutlet PlayerView *playerView;
	@property (nonatomic, weak) IBOutlet UIButton *playButton;
	- (IBAction)loadAssetFromFile:sender;
	- (IBAction)play:sender;
	- (void)syncUI;
	@end

The syncUI method synchronizes the button’s state with the player’s state:

其中 `syncUI` 方法是用来同步按钮和播放器状态的:

	- (void)syncUI {
	    if ((self.player.currentItem != nil) &&
	        ([self.player.currentItem status] == AVPlayerItemStatusReadyToPlay)) {
	        self.playButton.enabled = YES;
	    }
	    else {
	        self.playButton.enabled = NO;
	    }
	}

You can invoke syncUI in the view controller’s viewDidLoad method to ensure a consistent user interface when the view is first displayed.

你可以在视图控制器的 `viewDidLoad` 方法中调用 `syncUI`，以此来保证界面第一次显示时的一致性；

	- (void)viewDidLoad {
	    [super viewDidLoad];
	    [self syncUI];
	}

The other properties and methods are described in the remaining sections.

其他的属性和方法将在后面说明。

#### 创建 Asset  Creating the Asset

You create an asset from a URL using [AVURLAsset](https://developer.apple.com/documentation/avfoundation/avurlasset). (The following example assumes your project contains a suitable video resource.)

你可以使用 [AVURLAsset](https://developer.apple.com/documentation/avfoundation/avurlasset) 来创建一个基于 URL 的  `asset`。（以下代码假设项目中已经有一个可用的视频资源）

	- (IBAction)loadAssetFromFile:sender {
	 
	    NSURL *fileURL = [[NSBundle mainBundle]
	        URLForResource:<#@"VideoFileName"#> withExtension:<#@"extension"#>];
	 
	    AVURLAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil];
	    NSString *tracksKey = @"tracks";
	 
	    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:
	     ^{
	         // The completion block goes here.
	     }];
	}

In the completion block, you create an instance of [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem) for the asset and set it as the player for the player view. As with creating the asset, simply creating the player item does not mean it’s ready to use. To determine when it’s ready to play, you can observe the item’s status property. You should configure this observing before associating the player item instance with the player itself.

You trigger the player item’s preparation to play when you associate it with the player.

在完成的回调中，你用这个 asset 来创建一个 [AVPlayerItem](https://developer.apple.com/documentation/avfoundation/avplayeritem) 对象，并把他交给播放视图的播放器。当你创建 asset，然后简单的创建播放条目 (player item) 并不意味着他现在就可以使用了。你需要观察播放条目的 `status` 属性来确定他可是否可以播放。你必须在将播放条目和播放器关联前就开始观察这个属性。

当你将播放器和播放条目关联的时候，你就是触发了这个准备过程。

	// Define this constant for the key-value observation context.
	static const NSString *ItemStatusContext;
	 
	// Completion handler block.
	         dispatch_async(dispatch_get_main_queue(),
	            ^{
	                NSError *error;
	                AVKeyValueStatus status = [asset statusOfValueForKey:tracksKey error:&error];
	 
	                if (status == AVKeyValueStatusLoaded) {
	                    self.playerItem = [AVPlayerItem playerItemWithAsset:asset];
	                     // ensure that this is done before the playerItem is associated with the player
	                    [self.playerItem addObserver:self forKeyPath:@"status"
	                                options:NSKeyValueObservingOptionInitial context:&ItemStatusContext];
	                    [[NSNotificationCenter defaultCenter] addObserver:self
	                                                              selector:@selector(playerItemDidReachEnd:)
	                                                                  name:AVPlayerItemDidPlayToEndTimeNotification
	                                                                object:self.playerItem];
	                    self.player = [AVPlayer playerWithPlayerItem:self.playerItem];
	                    [self.playerView setPlayer:self.player];
	                }
	                else {
	                    // You should deal with the error appropriately.
	                    NSLog(@"The asset's tracks were not loaded:\n%@", [error localizedDescription]);
	                }
	            });
	

#### 响应播放条目状态修改 Responding to the Player Item’s Status Change

When the player item’s status changes, the view controller receives a key-value observing change notification. AV Foundation does not specify what thread that the notification is sent on. If you want to update the user interface, you must make sure that any relevant code is invoked on the main thread. This example uses [dispatch\_async](https://developer.apple.com/documentation/dispatch/1453057-dispatch_async "dispatch_async") to queue a message on the main thread to synchronize the user interface.

当播放条目 `status` 属性改变的时候，视图控制器会接收到 `key-value observing` 的变化通知。`AVFoundation` 并没有指定是从哪个线程来接收消息的。所以你需要确保是在主线程中来处理用户界面更新的代码。下面的示例中，使用了 [dispatch\_async](https://developer.apple.com/documentation/dispatch/1453057-dispatch_async "dispatch_async") 将界面同步代码提交到主线程中运行。

	- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
	                        change:(NSDictionary *)change context:(void *)context {
	 
	    if (context == &ItemStatusContext) {
	        dispatch_async(dispatch_get_main_queue(),
	                       ^{
	                           [self syncUI];
	                       });
	        return;
	    }
	    [super observeValueForKeyPath:keyPath ofObject:object
	           change:change context:context];
	    return;
	}
	

#### 播放  Playing the Item

Playing the item involves sending a play message to the player.

向播放器发送一个 `play` 消息就可以播放这个条目。

	- (IBAction)play:sender {
	    [player play];
	}

The item is played only once. After playback, the player’s head is set to the end of the item, and further invocations of the play method will have no effect. To position the playhead back at the beginning of the item, you can register to receive an [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification) from the item. In the notification’s callback method, invoke [seekToTime:](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390153-seek) with the argument [kCMTimeZero](https://developer.apple.com/documentation/coremedia/kcmtimezero).

播放条目只会被播放一次。当播放完成后，播放头被被定位在结尾处了，而且再次调用播放不会有任何效果。你可以从播放条目注册接收一个 [AVPlayerItemDidPlayToEndTimeNotification](https://developer.apple.com/documentation/avfoundation/avplayeritemdidplaytoendtimenotification)  播放完成的通知。在通知回调中，通过使用 [kCMTimeZero](https://developer.apple.com/documentation/coremedia/kcmtimezero) 参数来调用 [seekToTime:](https://developer.apple.com/documentation/avfoundation/avplayeritem/1390153-seek)  将播放设置到开头。

	// Register with the notification center after creating the player item.
	    [[NSNotificationCenter defaultCenter]
	        addObserver:self
	        selector:@selector(playerItemDidReachEnd:)
	        name:AVPlayerItemDidPlayToEndTimeNotification
	        object:[self.player currentItem]];
	 
	- (void)playerItemDidReachEnd:(NSNotification *)notification {
	    [self.player seekToTime:kCMTimeZero];
	}


